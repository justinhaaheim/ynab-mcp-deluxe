/**
 * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/zoubingwu/msw-auto-mock)
 * Feel free to commit/edit it as you need.
 */
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
import {HttpResponse, http} from 'msw';
import {faker} from '@faker-js/faker';

faker.seed(1);

const baseURL = 'https://api.ynab.com/v1';
const MAX_ARRAY_LENGTH = 20;

// Map to store counters for each API endpoint
const apiCounters = new Map<string, number>();

const next = (apiKey: string) => {
  let currentCount = apiCounters.get(apiKey) ?? 0;
  if (currentCount === Number.MAX_SAFE_INTEGER - 1) {
    currentCount = 0;
  }
  apiCounters.set(apiKey, currentCount + 1);
  return currentCount;
};

export const handlers = [
  http.get(`${baseURL}/user`, async () => {
    const resultArray = [[getGetUser200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[next(`get /user`) % resultArray.length],
    );
  }),
  http.get(`${baseURL}/budgets`, async () => {
    const resultArray = [[getGetBudgets200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[next(`get /budgets`) % resultArray.length],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId`, async () => {
    const resultArray = [[getGetBudgetById200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[next(`get /budgets/:budgetId`) % resultArray.length],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId/settings`, async () => {
    const resultArray = [
      [getGetBudgetSettingsById200Response(), {status: 200}],
    ] as [any, {status: number}][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/settings`) % resultArray.length
      ],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId/accounts`, async () => {
    const resultArray = [[getGetAccounts200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/accounts`) % resultArray.length
      ],
    );
  }),
  http.post(`${baseURL}/budgets/:budgetId/accounts`, async () => {
    const resultArray = [[getCreateAccount201Response(), {status: 201}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`post /budgets/:budgetId/accounts`) % resultArray.length
      ],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId/accounts/:accountId`, async () => {
    const resultArray = [[getGetAccountById200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/accounts/:accountId`) % resultArray.length
      ],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId/categories`, async () => {
    const resultArray = [[getGetCategories200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/categories`) % resultArray.length
      ],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId/categories/:categoryId`, async () => {
    const resultArray = [[getGetCategoryById200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/categories/:categoryId`) %
          resultArray.length
      ],
    );
  }),
  http.patch(
    `${baseURL}/budgets/:budgetId/categories/:categoryId`,
    async () => {
      const resultArray = [[getUpdateCategory200Response(), {status: 200}]] as [
        any,
        {status: number},
      ][];

      return HttpResponse.json(
        ...resultArray[
          next(`patch /budgets/:budgetId/categories/:categoryId`) %
            resultArray.length
        ],
      );
    },
  ),
  http.get(
    `${baseURL}/budgets/:budgetId/months/:month/categories/:categoryId`,
    async () => {
      const resultArray = [
        [getGetMonthCategoryById200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`get /budgets/:budgetId/months/:month/categories/:categoryId`) %
            resultArray.length
        ],
      );
    },
  ),
  http.patch(
    `${baseURL}/budgets/:budgetId/months/:month/categories/:categoryId`,
    async () => {
      const resultArray = [
        [getUpdateMonthCategory200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(
            `patch /budgets/:budgetId/months/:month/categories/:categoryId`,
          ) % resultArray.length
        ],
      );
    },
  ),
  http.get(`${baseURL}/budgets/:budgetId/payees`, async () => {
    const resultArray = [[getGetPayees200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/payees`) % resultArray.length
      ],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId/payees/:payeeId`, async () => {
    const resultArray = [[getGetPayeeById200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/payees/:payeeId`) % resultArray.length
      ],
    );
  }),
  http.patch(`${baseURL}/budgets/:budgetId/payees/:payeeId`, async () => {
    const resultArray = [[getUpdatePayee200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`patch /budgets/:budgetId/payees/:payeeId`) % resultArray.length
      ],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId/payee_locations`, async () => {
    const resultArray = [
      [getGetPayeeLocations200Response(), {status: 200}],
    ] as [any, {status: number}][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/payee_locations`) % resultArray.length
      ],
    );
  }),
  http.get(
    `${baseURL}/budgets/:budgetId/payee_locations/:payeeLocationId`,
    async () => {
      const resultArray = [
        [getGetPayeeLocationById200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`get /budgets/:budgetId/payee_locations/:payeeLocationId`) %
            resultArray.length
        ],
      );
    },
  ),
  http.get(
    `${baseURL}/budgets/:budgetId/payees/:payeeId/payee_locations`,
    async () => {
      const resultArray = [
        [getGetPayeeLocationsByPayee200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`get /budgets/:budgetId/payees/:payeeId/payee_locations`) %
            resultArray.length
        ],
      );
    },
  ),
  http.get(`${baseURL}/budgets/:budgetId/months`, async () => {
    const resultArray = [[getGetBudgetMonths200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/months`) % resultArray.length
      ],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId/months/:month`, async () => {
    const resultArray = [[getGetBudgetMonth200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/months/:month`) % resultArray.length
      ],
    );
  }),
  http.get(`${baseURL}/budgets/:budgetId/transactions`, async () => {
    const resultArray = [[getGetTransactions200Response(), {status: 200}]] as [
      any,
      {status: number},
    ][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/transactions`) % resultArray.length
      ],
    );
  }),
  http.post(`${baseURL}/budgets/:budgetId/transactions`, async () => {
    const resultArray = [
      [getCreateTransaction201Response(), {status: 201}],
    ] as [any, {status: number}][];

    return HttpResponse.json(
      ...resultArray[
        next(`post /budgets/:budgetId/transactions`) % resultArray.length
      ],
    );
  }),
  http.patch(`${baseURL}/budgets/:budgetId/transactions`, async () => {
    const resultArray = [
      [getUpdateTransactions200Response(), {status: 200}],
    ] as [any, {status: number}][];

    return HttpResponse.json(
      ...resultArray[
        next(`patch /budgets/:budgetId/transactions`) % resultArray.length
      ],
    );
  }),
  http.post(`${baseURL}/budgets/:budgetId/transactions/import`, async () => {
    const resultArray = [
      [getImportTransactions200Response(), {status: 200}],
      [getImportTransactions201Response(), {status: 201}],
    ] as [any, {status: number}][];

    return HttpResponse.json(
      ...resultArray[
        next(`post /budgets/:budgetId/transactions/import`) % resultArray.length
      ],
    );
  }),
  http.get(
    `${baseURL}/budgets/:budgetId/transactions/:transactionId`,
    async () => {
      const resultArray = [
        [getGetTransactionById200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`get /budgets/:budgetId/transactions/:transactionId`) %
            resultArray.length
        ],
      );
    },
  ),
  http.put(
    `${baseURL}/budgets/:budgetId/transactions/:transactionId`,
    async () => {
      const resultArray = [
        [getUpdateTransaction200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`put /budgets/:budgetId/transactions/:transactionId`) %
            resultArray.length
        ],
      );
    },
  ),
  http.delete(
    `${baseURL}/budgets/:budgetId/transactions/:transactionId`,
    async () => {
      const resultArray = [
        [getDeleteTransaction200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`delete /budgets/:budgetId/transactions/:transactionId`) %
            resultArray.length
        ],
      );
    },
  ),
  http.get(
    `${baseURL}/budgets/:budgetId/accounts/:accountId/transactions`,
    async () => {
      const resultArray = [
        [getGetTransactionsByAccount200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`get /budgets/:budgetId/accounts/:accountId/transactions`) %
            resultArray.length
        ],
      );
    },
  ),
  http.get(
    `${baseURL}/budgets/:budgetId/categories/:categoryId/transactions`,
    async () => {
      const resultArray = [
        [getGetTransactionsByCategory200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`get /budgets/:budgetId/categories/:categoryId/transactions`) %
            resultArray.length
        ],
      );
    },
  ),
  http.get(
    `${baseURL}/budgets/:budgetId/payees/:payeeId/transactions`,
    async () => {
      const resultArray = [
        [getGetTransactionsByPayee200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`get /budgets/:budgetId/payees/:payeeId/transactions`) %
            resultArray.length
        ],
      );
    },
  ),
  http.get(
    `${baseURL}/budgets/:budgetId/months/:month/transactions`,
    async () => {
      const resultArray = [
        [getGetTransactionsByMonth200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(`get /budgets/:budgetId/months/:month/transactions`) %
            resultArray.length
        ],
      );
    },
  ),
  http.get(`${baseURL}/budgets/:budgetId/scheduled_transactions`, async () => {
    const resultArray = [
      [getGetScheduledTransactions200Response(), {status: 200}],
    ] as [any, {status: number}][];

    return HttpResponse.json(
      ...resultArray[
        next(`get /budgets/:budgetId/scheduled_transactions`) %
          resultArray.length
      ],
    );
  }),
  http.post(`${baseURL}/budgets/:budgetId/scheduled_transactions`, async () => {
    const resultArray = [
      [getCreateScheduledTransaction201Response(), {status: 201}],
    ] as [any, {status: number}][];

    return HttpResponse.json(
      ...resultArray[
        next(`post /budgets/:budgetId/scheduled_transactions`) %
          resultArray.length
      ],
    );
  }),
  http.get(
    `${baseURL}/budgets/:budgetId/scheduled_transactions/:scheduledTransactionId`,
    async () => {
      const resultArray = [
        [getGetScheduledTransactionById200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(
            `get /budgets/:budgetId/scheduled_transactions/:scheduledTransactionId`,
          ) % resultArray.length
        ],
      );
    },
  ),
  http.put(
    `${baseURL}/budgets/:budgetId/scheduled_transactions/:scheduledTransactionId`,
    async () => {
      const resultArray = [
        [getUpdateScheduledTransaction200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(
            `put /budgets/:budgetId/scheduled_transactions/:scheduledTransactionId`,
          ) % resultArray.length
        ],
      );
    },
  ),
  http.delete(
    `${baseURL}/budgets/:budgetId/scheduled_transactions/:scheduledTransactionId`,
    async () => {
      const resultArray = [
        [getDeleteScheduledTransaction200Response(), {status: 200}],
      ] as [any, {status: number}][];

      return HttpResponse.json(
        ...resultArray[
          next(
            `delete /budgets/:budgetId/scheduled_transactions/:scheduledTransactionId`,
          ) % resultArray.length
        ],
      );
    },
  ),
];

export function getGetUser200Response() {
  return {
    data: {
      user: {
        id: faker.string.uuid(),
      },
    },
  };
}

export function getGetBudgets200Response() {
  return {
    data: {
      budgets: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        last_modified_on: faker.date.past(),
        first_month: faker.date.past().toISOString().substring(0, 10),
        last_month: faker.date.past().toISOString().substring(0, 10),
        date_format: {
          format: faker.lorem.words(),
        },
        currency_format: {
          iso_code: faker.lorem.words(),
          example_format: faker.lorem.words(),
          decimal_digits: faker.number.int(),
          decimal_separator: faker.lorem.words(),
          symbol_first: faker.datatype.boolean(),
          group_separator: faker.lorem.words(),
          currency_symbol: faker.lorem.words(),
          display_symbol: faker.datatype.boolean(),
        },
        accounts: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          name: faker.person.fullName(),
          type: faker.helpers.arrayElement([
            'checking',
            'savings',
            'cash',
            'creditCard',
            'lineOfCredit',
            'otherAsset',
            'otherLiability',
            'mortgage',
            'autoLoan',
            'studentLoan',
            'personalLoan',
            'medicalDebt',
            'otherDebt',
          ]),
          on_budget: faker.datatype.boolean(),
          closed: faker.datatype.boolean(),
          note: faker.lorem.words(),
          balance: faker.number.int(),
          cleared_balance: faker.number.int(),
          uncleared_balance: faker.number.int(),
          transfer_payee_id: faker.string.uuid(),
          direct_import_linked: faker.datatype.boolean(),
          direct_import_in_error: faker.datatype.boolean(),
          last_reconciled_at: faker.date.past(),
          debt_original_balance: faker.number.int(),
          debt_interest_rates: [...new Array(5).keys()]
            .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          debt_minimum_payments: [...new Array(5).keys()]
            .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          debt_escrow_amounts: [...new Array(5).keys()]
            .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          deleted: faker.datatype.boolean(),
        })),
      })),
      default_budget: {
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        last_modified_on: faker.date.past(),
        first_month: faker.date.past().toISOString().substring(0, 10),
        last_month: faker.date.past().toISOString().substring(0, 10),
        date_format: {
          format: faker.lorem.words(),
        },
        currency_format: {
          iso_code: faker.lorem.words(),
          example_format: faker.lorem.words(),
          decimal_digits: faker.number.int(),
          decimal_separator: faker.lorem.words(),
          symbol_first: faker.datatype.boolean(),
          group_separator: faker.lorem.words(),
          currency_symbol: faker.lorem.words(),
          display_symbol: faker.datatype.boolean(),
        },
        accounts: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          name: faker.person.fullName(),
          type: faker.helpers.arrayElement([
            'checking',
            'savings',
            'cash',
            'creditCard',
            'lineOfCredit',
            'otherAsset',
            'otherLiability',
            'mortgage',
            'autoLoan',
            'studentLoan',
            'personalLoan',
            'medicalDebt',
            'otherDebt',
          ]),
          on_budget: faker.datatype.boolean(),
          closed: faker.datatype.boolean(),
          note: faker.lorem.words(),
          balance: faker.number.int(),
          cleared_balance: faker.number.int(),
          uncleared_balance: faker.number.int(),
          transfer_payee_id: faker.string.uuid(),
          direct_import_linked: faker.datatype.boolean(),
          direct_import_in_error: faker.datatype.boolean(),
          last_reconciled_at: faker.date.past(),
          debt_original_balance: faker.number.int(),
          debt_interest_rates: [...new Array(5).keys()]
            .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          debt_minimum_payments: [...new Array(5).keys()]
            .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          debt_escrow_amounts: [...new Array(5).keys()]
            .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          deleted: faker.datatype.boolean(),
        })),
      },
    },
  };
}

export function getGetBudgetById200Response() {
  return {
    data: {
      budget: {
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        last_modified_on: faker.date.past(),
        first_month: faker.date.past().toISOString().substring(0, 10),
        last_month: faker.date.past().toISOString().substring(0, 10),
        date_format: {
          format: faker.lorem.words(),
        },
        currency_format: {
          iso_code: faker.lorem.words(),
          example_format: faker.lorem.words(),
          decimal_digits: faker.number.int(),
          decimal_separator: faker.lorem.words(),
          symbol_first: faker.datatype.boolean(),
          group_separator: faker.lorem.words(),
          currency_symbol: faker.lorem.words(),
          display_symbol: faker.datatype.boolean(),
        },
        accounts: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          name: faker.person.fullName(),
          type: faker.helpers.arrayElement([
            'checking',
            'savings',
            'cash',
            'creditCard',
            'lineOfCredit',
            'otherAsset',
            'otherLiability',
            'mortgage',
            'autoLoan',
            'studentLoan',
            'personalLoan',
            'medicalDebt',
            'otherDebt',
          ]),
          on_budget: faker.datatype.boolean(),
          closed: faker.datatype.boolean(),
          note: faker.lorem.words(),
          balance: faker.number.int(),
          cleared_balance: faker.number.int(),
          uncleared_balance: faker.number.int(),
          transfer_payee_id: faker.string.uuid(),
          direct_import_linked: faker.datatype.boolean(),
          direct_import_in_error: faker.datatype.boolean(),
          last_reconciled_at: faker.date.past(),
          debt_original_balance: faker.number.int(),
          debt_interest_rates: [...new Array(5).keys()]
            .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          debt_minimum_payments: [...new Array(5).keys()]
            .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          debt_escrow_amounts: [...new Array(5).keys()]
            .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          deleted: faker.datatype.boolean(),
        })),
        payees: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
        payee_locations: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          payee_id: faker.string.uuid(),
          latitude: faker.lorem.words(),
          longitude: faker.lorem.words(),
          deleted: faker.datatype.boolean(),
        })),
        category_groups: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          name: faker.person.fullName(),
          hidden: faker.datatype.boolean(),
          deleted: faker.datatype.boolean(),
        })),
        categories: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          category_group_id: faker.string.uuid(),
          category_group_name: faker.person.fullName(),
          name: faker.person.fullName(),
          hidden: faker.datatype.boolean(),
          original_category_group_id: faker.string.uuid(),
          note: faker.lorem.words(),
          budgeted: faker.number.int(),
          activity: faker.number.int(),
          balance: faker.number.int(),
          goal_type: faker.helpers.arrayElement([
            'TB',
            'TBD',
            'MF',
            'NEED',
            'DEBT',
            null,
          ]),
          goal_needs_whole_amount: faker.datatype.boolean(),
          goal_day: faker.number.int(),
          goal_cadence: faker.number.int(),
          goal_cadence_frequency: faker.number.int(),
          goal_creation_month: faker.date.past().toISOString().substring(0, 10),
          goal_target: faker.number.int(),
          goal_target_month: faker.date.past().toISOString().substring(0, 10),
          goal_percentage_complete: faker.number.int(),
          goal_months_to_budget: faker.number.int(),
          goal_under_funded: faker.number.int(),
          goal_overall_funded: faker.number.int(),
          goal_overall_left: faker.number.int(),
          goal_snoozed_at: faker.date.past(),
          deleted: faker.datatype.boolean(),
        })),
        months: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          month: faker.date.past().toISOString().substring(0, 10),
          note: faker.lorem.words(),
          income: faker.number.int(),
          budgeted: faker.number.int(),
          activity: faker.number.int(),
          to_be_budgeted: faker.number.int(),
          age_of_money: faker.number.int(),
          deleted: faker.datatype.boolean(),
          categories: [
            ...new Array(
              faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
            ).keys(),
          ].map((_) => ({
            id: faker.string.uuid(),
            category_group_id: faker.string.uuid(),
            category_group_name: faker.person.fullName(),
            name: faker.person.fullName(),
            hidden: faker.datatype.boolean(),
            original_category_group_id: faker.string.uuid(),
            note: faker.lorem.words(),
            budgeted: faker.number.int(),
            activity: faker.number.int(),
            balance: faker.number.int(),
            goal_type: faker.helpers.arrayElement([
              'TB',
              'TBD',
              'MF',
              'NEED',
              'DEBT',
              null,
            ]),
            goal_needs_whole_amount: faker.datatype.boolean(),
            goal_day: faker.number.int(),
            goal_cadence: faker.number.int(),
            goal_cadence_frequency: faker.number.int(),
            goal_creation_month: faker.date
              .past()
              .toISOString()
              .substring(0, 10),
            goal_target: faker.number.int(),
            goal_target_month: faker.date.past().toISOString().substring(0, 10),
            goal_percentage_complete: faker.number.int(),
            goal_months_to_budget: faker.number.int(),
            goal_under_funded: faker.number.int(),
            goal_overall_funded: faker.number.int(),
            goal_overall_left: faker.number.int(),
            goal_snoozed_at: faker.date.past(),
            deleted: faker.datatype.boolean(),
          })),
        })),
        transactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          date: faker.date.past().toISOString().substring(0, 10),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          cleared: faker.helpers.arrayElement([
            'cleared',
            'uncleared',
            'reconciled',
          ]),
          approved: faker.datatype.boolean(),
          flag_color: faker.helpers.arrayElement([
            'red',
            'orange',
            'yellow',
            'green',
            'blue',
            'purple',
            '',
            null,
          ]),
          flag_name: faker.person.fullName(),
          account_id: faker.string.uuid(),
          payee_id: faker.string.uuid(),
          category_id: faker.string.uuid(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          matched_transaction_id: faker.string.uuid(),
          import_id: faker.string.uuid(),
          import_payee_name: faker.person.fullName(),
          import_payee_name_original: faker.lorem.words(),
          debt_transaction_type: faker.helpers.arrayElement([
            'payment',
            'refund',
            'fee',
            'interest',
            'escrow',
            'balanceAdjustment',
            'credit',
            'charge',
            null,
          ]),
          deleted: faker.datatype.boolean(),
        })),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
        scheduled_transactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          date_first: faker.date.past().toISOString().substring(0, 10),
          date_next: faker.date.past().toISOString().substring(0, 10),
          frequency: faker.helpers.arrayElement([
            'never',
            'daily',
            'weekly',
            'everyOtherWeek',
            'twiceAMonth',
            'every4Weeks',
            'monthly',
            'everyOtherMonth',
            'every3Months',
            'every4Months',
            'twiceAYear',
            'yearly',
            'everyOtherYear',
          ]),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          flag_color: faker.helpers.arrayElement([
            'red',
            'orange',
            'yellow',
            'green',
            'blue',
            'purple',
            '',
            null,
          ]),
          flag_name: faker.person.fullName(),
          account_id: faker.string.uuid(),
          payee_id: faker.string.uuid(),
          category_id: faker.string.uuid(),
          transfer_account_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
        scheduled_subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          scheduled_transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      },
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetBudgetSettingsById200Response() {
  return {
    data: {
      settings: {
        date_format: {
          format: faker.lorem.words(),
        },
        currency_format: {
          iso_code: faker.lorem.words(),
          example_format: faker.lorem.words(),
          decimal_digits: faker.number.int(),
          decimal_separator: faker.lorem.words(),
          symbol_first: faker.datatype.boolean(),
          group_separator: faker.lorem.words(),
          currency_symbol: faker.lorem.words(),
          display_symbol: faker.datatype.boolean(),
        },
      },
    },
  };
}

export function getGetAccounts200Response() {
  return {
    data: {
      accounts: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        type: faker.helpers.arrayElement([
          'checking',
          'savings',
          'cash',
          'creditCard',
          'lineOfCredit',
          'otherAsset',
          'otherLiability',
          'mortgage',
          'autoLoan',
          'studentLoan',
          'personalLoan',
          'medicalDebt',
          'otherDebt',
        ]),
        on_budget: faker.datatype.boolean(),
        closed: faker.datatype.boolean(),
        note: faker.lorem.words(),
        balance: faker.number.int(),
        cleared_balance: faker.number.int(),
        uncleared_balance: faker.number.int(),
        transfer_payee_id: faker.string.uuid(),
        direct_import_linked: faker.datatype.boolean(),
        direct_import_in_error: faker.datatype.boolean(),
        last_reconciled_at: faker.date.past(),
        debt_original_balance: faker.number.int(),
        debt_interest_rates: [...new Array(5).keys()]
          .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        debt_minimum_payments: [...new Array(5).keys()]
          .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        debt_escrow_amounts: [...new Array(5).keys()]
          .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        deleted: faker.datatype.boolean(),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getCreateAccount201Response() {
  return {
    data: {
      account: {
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        type: faker.helpers.arrayElement([
          'checking',
          'savings',
          'cash',
          'creditCard',
          'lineOfCredit',
          'otherAsset',
          'otherLiability',
          'mortgage',
          'autoLoan',
          'studentLoan',
          'personalLoan',
          'medicalDebt',
          'otherDebt',
        ]),
        on_budget: faker.datatype.boolean(),
        closed: faker.datatype.boolean(),
        note: faker.lorem.words(),
        balance: faker.number.int(),
        cleared_balance: faker.number.int(),
        uncleared_balance: faker.number.int(),
        transfer_payee_id: faker.string.uuid(),
        direct_import_linked: faker.datatype.boolean(),
        direct_import_in_error: faker.datatype.boolean(),
        last_reconciled_at: faker.date.past(),
        debt_original_balance: faker.number.int(),
        debt_interest_rates: [...new Array(5).keys()]
          .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        debt_minimum_payments: [...new Array(5).keys()]
          .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        debt_escrow_amounts: [...new Array(5).keys()]
          .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        deleted: faker.datatype.boolean(),
      },
    },
  };
}

export function getGetAccountById200Response() {
  return {
    data: {
      account: {
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        type: faker.helpers.arrayElement([
          'checking',
          'savings',
          'cash',
          'creditCard',
          'lineOfCredit',
          'otherAsset',
          'otherLiability',
          'mortgage',
          'autoLoan',
          'studentLoan',
          'personalLoan',
          'medicalDebt',
          'otherDebt',
        ]),
        on_budget: faker.datatype.boolean(),
        closed: faker.datatype.boolean(),
        note: faker.lorem.words(),
        balance: faker.number.int(),
        cleared_balance: faker.number.int(),
        uncleared_balance: faker.number.int(),
        transfer_payee_id: faker.string.uuid(),
        direct_import_linked: faker.datatype.boolean(),
        direct_import_in_error: faker.datatype.boolean(),
        last_reconciled_at: faker.date.past(),
        debt_original_balance: faker.number.int(),
        debt_interest_rates: [...new Array(5).keys()]
          .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        debt_minimum_payments: [...new Array(5).keys()]
          .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        debt_escrow_amounts: [...new Array(5).keys()]
          .map((_) => ({[faker.lorem.word()]: faker.number.int()}))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        deleted: faker.datatype.boolean(),
      },
    },
  };
}

export function getGetCategories200Response() {
  return {
    data: {
      category_groups: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        hidden: faker.datatype.boolean(),
        deleted: faker.datatype.boolean(),
        categories: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          category_group_id: faker.string.uuid(),
          category_group_name: faker.person.fullName(),
          name: faker.person.fullName(),
          hidden: faker.datatype.boolean(),
          original_category_group_id: faker.string.uuid(),
          note: faker.lorem.words(),
          budgeted: faker.number.int(),
          activity: faker.number.int(),
          balance: faker.number.int(),
          goal_type: faker.helpers.arrayElement([
            'TB',
            'TBD',
            'MF',
            'NEED',
            'DEBT',
            null,
          ]),
          goal_needs_whole_amount: faker.datatype.boolean(),
          goal_day: faker.number.int(),
          goal_cadence: faker.number.int(),
          goal_cadence_frequency: faker.number.int(),
          goal_creation_month: faker.date.past().toISOString().substring(0, 10),
          goal_target: faker.number.int(),
          goal_target_month: faker.date.past().toISOString().substring(0, 10),
          goal_percentage_complete: faker.number.int(),
          goal_months_to_budget: faker.number.int(),
          goal_under_funded: faker.number.int(),
          goal_overall_funded: faker.number.int(),
          goal_overall_left: faker.number.int(),
          goal_snoozed_at: faker.date.past(),
          deleted: faker.datatype.boolean(),
        })),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetCategoryById200Response() {
  return {
    data: {
      category: {
        id: faker.string.uuid(),
        category_group_id: faker.string.uuid(),
        category_group_name: faker.person.fullName(),
        name: faker.person.fullName(),
        hidden: faker.datatype.boolean(),
        original_category_group_id: faker.string.uuid(),
        note: faker.lorem.words(),
        budgeted: faker.number.int(),
        activity: faker.number.int(),
        balance: faker.number.int(),
        goal_type: faker.helpers.arrayElement([
          'TB',
          'TBD',
          'MF',
          'NEED',
          'DEBT',
          null,
        ]),
        goal_needs_whole_amount: faker.datatype.boolean(),
        goal_day: faker.number.int(),
        goal_cadence: faker.number.int(),
        goal_cadence_frequency: faker.number.int(),
        goal_creation_month: faker.date.past().toISOString().substring(0, 10),
        goal_target: faker.number.int(),
        goal_target_month: faker.date.past().toISOString().substring(0, 10),
        goal_percentage_complete: faker.number.int(),
        goal_months_to_budget: faker.number.int(),
        goal_under_funded: faker.number.int(),
        goal_overall_funded: faker.number.int(),
        goal_overall_left: faker.number.int(),
        goal_snoozed_at: faker.date.past(),
        deleted: faker.datatype.boolean(),
      },
    },
  };
}

export function getUpdateCategory200Response() {
  return {
    data: {
      category: {
        id: faker.string.uuid(),
        category_group_id: faker.string.uuid(),
        category_group_name: faker.person.fullName(),
        name: faker.person.fullName(),
        hidden: faker.datatype.boolean(),
        original_category_group_id: faker.string.uuid(),
        note: faker.lorem.words(),
        budgeted: faker.number.int(),
        activity: faker.number.int(),
        balance: faker.number.int(),
        goal_type: faker.helpers.arrayElement([
          'TB',
          'TBD',
          'MF',
          'NEED',
          'DEBT',
          null,
        ]),
        goal_needs_whole_amount: faker.datatype.boolean(),
        goal_day: faker.number.int(),
        goal_cadence: faker.number.int(),
        goal_cadence_frequency: faker.number.int(),
        goal_creation_month: faker.date.past().toISOString().substring(0, 10),
        goal_target: faker.number.int(),
        goal_target_month: faker.date.past().toISOString().substring(0, 10),
        goal_percentage_complete: faker.number.int(),
        goal_months_to_budget: faker.number.int(),
        goal_under_funded: faker.number.int(),
        goal_overall_funded: faker.number.int(),
        goal_overall_left: faker.number.int(),
        goal_snoozed_at: faker.date.past(),
        deleted: faker.datatype.boolean(),
      },
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetMonthCategoryById200Response() {
  return {
    data: {
      category: {
        id: faker.string.uuid(),
        category_group_id: faker.string.uuid(),
        category_group_name: faker.person.fullName(),
        name: faker.person.fullName(),
        hidden: faker.datatype.boolean(),
        original_category_group_id: faker.string.uuid(),
        note: faker.lorem.words(),
        budgeted: faker.number.int(),
        activity: faker.number.int(),
        balance: faker.number.int(),
        goal_type: faker.helpers.arrayElement([
          'TB',
          'TBD',
          'MF',
          'NEED',
          'DEBT',
          null,
        ]),
        goal_needs_whole_amount: faker.datatype.boolean(),
        goal_day: faker.number.int(),
        goal_cadence: faker.number.int(),
        goal_cadence_frequency: faker.number.int(),
        goal_creation_month: faker.date.past().toISOString().substring(0, 10),
        goal_target: faker.number.int(),
        goal_target_month: faker.date.past().toISOString().substring(0, 10),
        goal_percentage_complete: faker.number.int(),
        goal_months_to_budget: faker.number.int(),
        goal_under_funded: faker.number.int(),
        goal_overall_funded: faker.number.int(),
        goal_overall_left: faker.number.int(),
        goal_snoozed_at: faker.date.past(),
        deleted: faker.datatype.boolean(),
      },
    },
  };
}

export function getUpdateMonthCategory200Response() {
  return {
    data: {
      category: {
        id: faker.string.uuid(),
        category_group_id: faker.string.uuid(),
        category_group_name: faker.person.fullName(),
        name: faker.person.fullName(),
        hidden: faker.datatype.boolean(),
        original_category_group_id: faker.string.uuid(),
        note: faker.lorem.words(),
        budgeted: faker.number.int(),
        activity: faker.number.int(),
        balance: faker.number.int(),
        goal_type: faker.helpers.arrayElement([
          'TB',
          'TBD',
          'MF',
          'NEED',
          'DEBT',
          null,
        ]),
        goal_needs_whole_amount: faker.datatype.boolean(),
        goal_day: faker.number.int(),
        goal_cadence: faker.number.int(),
        goal_cadence_frequency: faker.number.int(),
        goal_creation_month: faker.date.past().toISOString().substring(0, 10),
        goal_target: faker.number.int(),
        goal_target_month: faker.date.past().toISOString().substring(0, 10),
        goal_percentage_complete: faker.number.int(),
        goal_months_to_budget: faker.number.int(),
        goal_under_funded: faker.number.int(),
        goal_overall_funded: faker.number.int(),
        goal_overall_left: faker.number.int(),
        goal_snoozed_at: faker.date.past(),
        deleted: faker.datatype.boolean(),
      },
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetPayees200Response() {
  return {
    data: {
      payees: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        transfer_account_id: faker.string.uuid(),
        deleted: faker.datatype.boolean(),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetPayeeById200Response() {
  return {
    data: {
      payee: {
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        transfer_account_id: faker.string.uuid(),
        deleted: faker.datatype.boolean(),
      },
    },
  };
}

export function getUpdatePayee200Response() {
  return {
    data: {
      payee: {
        id: faker.string.uuid(),
        name: faker.person.fullName(),
        transfer_account_id: faker.string.uuid(),
        deleted: faker.datatype.boolean(),
      },
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetPayeeLocations200Response() {
  return {
    data: {
      payee_locations: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        latitude: faker.lorem.words(),
        longitude: faker.lorem.words(),
        deleted: faker.datatype.boolean(),
      })),
    },
  };
}

export function getGetPayeeLocationById200Response() {
  return {
    data: {
      payee_location: {
        id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        latitude: faker.lorem.words(),
        longitude: faker.lorem.words(),
        deleted: faker.datatype.boolean(),
      },
    },
  };
}

export function getGetPayeeLocationsByPayee200Response() {
  return {
    data: {
      payee_locations: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        latitude: faker.lorem.words(),
        longitude: faker.lorem.words(),
        deleted: faker.datatype.boolean(),
      })),
    },
  };
}

export function getGetBudgetMonths200Response() {
  return {
    data: {
      months: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        month: faker.date.past().toISOString().substring(0, 10),
        note: faker.lorem.words(),
        income: faker.number.int(),
        budgeted: faker.number.int(),
        activity: faker.number.int(),
        to_be_budgeted: faker.number.int(),
        age_of_money: faker.number.int(),
        deleted: faker.datatype.boolean(),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetBudgetMonth200Response() {
  return {
    data: {
      month: {
        month: faker.date.past().toISOString().substring(0, 10),
        note: faker.lorem.words(),
        income: faker.number.int(),
        budgeted: faker.number.int(),
        activity: faker.number.int(),
        to_be_budgeted: faker.number.int(),
        age_of_money: faker.number.int(),
        deleted: faker.datatype.boolean(),
        categories: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          category_group_id: faker.string.uuid(),
          category_group_name: faker.person.fullName(),
          name: faker.person.fullName(),
          hidden: faker.datatype.boolean(),
          original_category_group_id: faker.string.uuid(),
          note: faker.lorem.words(),
          budgeted: faker.number.int(),
          activity: faker.number.int(),
          balance: faker.number.int(),
          goal_type: faker.helpers.arrayElement([
            'TB',
            'TBD',
            'MF',
            'NEED',
            'DEBT',
            null,
          ]),
          goal_needs_whole_amount: faker.datatype.boolean(),
          goal_day: faker.number.int(),
          goal_cadence: faker.number.int(),
          goal_cadence_frequency: faker.number.int(),
          goal_creation_month: faker.date.past().toISOString().substring(0, 10),
          goal_target: faker.number.int(),
          goal_target_month: faker.date.past().toISOString().substring(0, 10),
          goal_percentage_complete: faker.number.int(),
          goal_months_to_budget: faker.number.int(),
          goal_under_funded: faker.number.int(),
          goal_overall_funded: faker.number.int(),
          goal_overall_left: faker.number.int(),
          goal_snoozed_at: faker.date.past(),
          deleted: faker.datatype.boolean(),
        })),
      },
    },
  };
}

export function getGetTransactions200Response() {
  return {
    data: {
      transactions: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getCreateTransaction201Response() {
  return {
    data: {
      transaction_ids: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => faker.lorem.words()),
      transaction: {
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      },
      transactions: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      })),
      duplicate_import_ids: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => faker.lorem.words()),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getImportTransactions200Response() {
  return {
    data: {
      transaction_ids: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => faker.lorem.words()),
    },
  };
}

export function getImportTransactions201Response() {
  return {
    data: {
      transaction_ids: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => faker.lorem.words()),
    },
  };
}

export function getGetTransactionById200Response() {
  return {
    data: {
      transaction: {
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      },
      server_knowledge: faker.number.int(),
    },
  };
}

export function getUpdateTransaction200Response() {
  return {
    data: {
      transaction: {
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      },
      server_knowledge: faker.number.int(),
    },
  };
}

export function getDeleteTransaction200Response() {
  return {
    data: {
      transaction: {
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      },
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetTransactionsByAccount200Response() {
  return {
    data: {
      transactions: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetTransactionsByCategory200Response() {
  return {
    data: {
      transactions: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        type: faker.helpers.arrayElement(['transaction', 'subtransaction']),
        parent_transaction_id: faker.string.uuid(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetTransactionsByPayee200Response() {
  return {
    data: {
      transactions: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        type: faker.helpers.arrayElement(['transaction', 'subtransaction']),
        parent_transaction_id: faker.string.uuid(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetTransactionsByMonth200Response() {
  return {
    data: {
      transactions: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getGetScheduledTransactions200Response() {
  return {
    data: {
      scheduled_transactions: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        date_first: faker.date.past().toISOString().substring(0, 10),
        date_next: faker.date.past().toISOString().substring(0, 10),
        frequency: faker.helpers.arrayElement([
          'never',
          'daily',
          'weekly',
          'everyOtherWeek',
          'twiceAMonth',
          'every4Weeks',
          'monthly',
          'everyOtherMonth',
          'every3Months',
          'every4Months',
          'twiceAYear',
          'yearly',
          'everyOtherYear',
        ]),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          scheduled_transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}

export function getCreateScheduledTransaction201Response() {
  return {
    data: {
      scheduled_transaction: {
        id: faker.string.uuid(),
        date_first: faker.date.past().toISOString().substring(0, 10),
        date_next: faker.date.past().toISOString().substring(0, 10),
        frequency: faker.helpers.arrayElement([
          'never',
          'daily',
          'weekly',
          'everyOtherWeek',
          'twiceAMonth',
          'every4Weeks',
          'monthly',
          'everyOtherMonth',
          'every3Months',
          'every4Months',
          'twiceAYear',
          'yearly',
          'everyOtherYear',
        ]),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          scheduled_transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      },
    },
  };
}

export function getGetScheduledTransactionById200Response() {
  return {
    data: {
      scheduled_transaction: {
        id: faker.string.uuid(),
        date_first: faker.date.past().toISOString().substring(0, 10),
        date_next: faker.date.past().toISOString().substring(0, 10),
        frequency: faker.helpers.arrayElement([
          'never',
          'daily',
          'weekly',
          'everyOtherWeek',
          'twiceAMonth',
          'every4Weeks',
          'monthly',
          'everyOtherMonth',
          'every3Months',
          'every4Months',
          'twiceAYear',
          'yearly',
          'everyOtherYear',
        ]),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          scheduled_transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      },
    },
  };
}

export function getUpdateScheduledTransaction200Response() {
  return {
    data: {
      scheduled_transaction: {
        id: faker.string.uuid(),
        date_first: faker.date.past().toISOString().substring(0, 10),
        date_next: faker.date.past().toISOString().substring(0, 10),
        frequency: faker.helpers.arrayElement([
          'never',
          'daily',
          'weekly',
          'everyOtherWeek',
          'twiceAMonth',
          'every4Weeks',
          'monthly',
          'everyOtherMonth',
          'every3Months',
          'every4Months',
          'twiceAYear',
          'yearly',
          'everyOtherYear',
        ]),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          scheduled_transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      },
    },
  };
}

export function getDeleteScheduledTransaction200Response() {
  return {
    data: {
      scheduled_transaction: {
        id: faker.string.uuid(),
        date_first: faker.date.past().toISOString().substring(0, 10),
        date_next: faker.date.past().toISOString().substring(0, 10),
        frequency: faker.helpers.arrayElement([
          'never',
          'daily',
          'weekly',
          'everyOtherWeek',
          'twiceAMonth',
          'every4Weeks',
          'monthly',
          'everyOtherMonth',
          'every3Months',
          'every4Months',
          'twiceAYear',
          'yearly',
          'everyOtherYear',
        ]),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          scheduled_transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      },
    },
  };
}

export function getUpdateTransactions200Response() {
  return {
    data: {
      transaction_ids: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => faker.string.uuid()),
      transactions: [
        ...new Array(faker.number.int({min: 1, max: MAX_ARRAY_LENGTH})).keys(),
      ].map((_) => ({
        id: faker.string.uuid(),
        date: faker.date.past().toISOString().substring(0, 10),
        amount: faker.number.int(),
        memo: faker.lorem.words(),
        cleared: faker.helpers.arrayElement([
          'cleared',
          'uncleared',
          'reconciled',
        ]),
        approved: faker.datatype.boolean(),
        flag_color: faker.helpers.arrayElement([
          'red',
          'orange',
          'yellow',
          'green',
          'blue',
          'purple',
          '',
          null,
        ]),
        flag_name: faker.person.fullName(),
        account_id: faker.string.uuid(),
        payee_id: faker.string.uuid(),
        category_id: faker.string.uuid(),
        transfer_account_id: faker.string.uuid(),
        transfer_transaction_id: faker.string.uuid(),
        matched_transaction_id: faker.string.uuid(),
        import_id: faker.string.uuid(),
        import_payee_name: faker.person.fullName(),
        import_payee_name_original: faker.lorem.words(),
        debt_transaction_type: faker.helpers.arrayElement([
          'payment',
          'refund',
          'fee',
          'interest',
          'escrow',
          'balanceAdjustment',
          'credit',
          'charge',
          null,
        ]),
        deleted: faker.datatype.boolean(),
        account_name: faker.person.fullName(),
        payee_name: faker.person.fullName(),
        category_name: faker.person.fullName(),
        subtransactions: [
          ...new Array(
            faker.number.int({min: 1, max: MAX_ARRAY_LENGTH}),
          ).keys(),
        ].map((_) => ({
          id: faker.string.uuid(),
          transaction_id: faker.string.uuid(),
          amount: faker.number.int(),
          memo: faker.lorem.words(),
          payee_id: faker.string.uuid(),
          payee_name: faker.person.fullName(),
          category_id: faker.string.uuid(),
          category_name: faker.person.fullName(),
          transfer_account_id: faker.string.uuid(),
          transfer_transaction_id: faker.string.uuid(),
          deleted: faker.datatype.boolean(),
        })),
      })),
      server_knowledge: faker.number.int(),
    },
  };
}
